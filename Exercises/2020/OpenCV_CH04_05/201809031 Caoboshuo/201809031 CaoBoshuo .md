## OpenCV第二次笔记作业

### 第四章 OpenCV 数据结构与基本绘图

### 基础图像容器 Mat

### 4.1.1 数字图像存储概述
我们可以通过各种各样的方法从现实世界获取到数字图像，如借助相机、扫描仪、计算机摄像头或磁共振成像等。通常由显示屏上看到的都是真实而漂亮的图像，但是这些图像在转化到我们的数字设备中时，记录的却是图像中的每个点的数值。
### 4.1.2 Mat结构的使用
自2001年以来，OpenCV的函数库一直是基于C接口构建的，因此在最初的几个OpenCV版本中,一般使用名为Ipllmage的C语言结构体在内存中存储图像。时至今日，这仍出现在大多数的旧版教程和教学材料中，如最经典的OpenCV教程《Learning OpenCV》。

关于Mat类，首先我们要知道的是:
(1）不必再手动为其开辟空间。
(2）不必再在不需要时立即将空间释放。

这里指的是手动开辟空间并非必须，但它依旧是存在的——大多数OpenCv函数仍会手动地为输出数据开辟空间。当传递一个已经存在的 Mat对象时，开辟好的矩阵空间会被重用。也就是说，我们每次都使用大小正好的内存来完成任务。

总而言之，Mat是一个类，由两个数据部分组成:矩阵头（包含矩阵尺寸、存储方法、存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同，矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建副本时，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是常有的事。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，不应该进行大图像的复制，因为这会降低程序的运行速度。

为了解决此问题，OpenCV使用了引用计数机制。其思路是让每个Mat对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则只复制信息头和矩阵指针，而不复制矩阵。

4.1.3 像素值的存储方法

本节我们将讲解如何存储像素值。存储像素值需要指定颜色空间和数据类型。其中，颜色空间是指针对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间，只处理黑色和白色，对它们进行组合便可以产生不同程度的灰色。

对于彩色方式则有更多种类的颜色空间，但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。RGB 颜色空间是最常用的一种颜色空间，这归功于它也是人眼内部构成颜色的方式。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素alpha (A)。

每个组成元素都有其自己的定义域，而定义域取决于其数据类型，如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ,占一个字节或者8位，可以是有符号型(O到255之间)或无符号型(-127到+127之间)。尽管使用三个char型元素已经可以表示1600万种可能的颜色(使用RGB颜色空间)，但若使用float(4字节，32位)或double (8字节，64位〉则能给出更加精细的颜色分辨能力。但同时也要切记，增加元素的尺寸也会增加图像所占的内存空间。

### 4.1.4 显式创建Mat对象的七种方法

在之前的章节中，我们已经讲解了如何使用函数imwrite()函数将一个矩阵写入图像文件中。但是作为debug，更加方便的方式是看实际值，我们可以通过Mat的运算符“<<”来实现。但要记住，Mat的运算符“<<”只对二维矩阵有效。

Mat不但是一个非常有用的图像容器类，同时也是一个通用的矩阵类，我们也可以用它来创建和操作多维矩阵。

创建一个Mat对象有多种方法，列举如下。

1.使用Mat()构造函数

2.在C\C++中通过构造函数进行初始化

3.为已存在的lpllmage 指针创建信息头

4.利用Create()函数

5.采用Matlab式的初始化方式

6.对小矩阵使用逗号分隔式初始化函数

7.为已存在的对象创建新信息头

### 4.1.5 OpenCV中的格式化输出方法

在上一个例子中我们可以看到有默认的格式选项，同时，OpenCV也提供了风格各异的格式化输出方法，本小节将对这些方法一一进行演示和列举。

首先是下面代码中将要使用的r矩阵的定义。需要注意,我们可以通过用randu()函数产生的随机值来填充矩阵，需要给定一个上限和下限来确保随机值在期望的范围内。

1．【风格一】OpenCV默认风格

2.【风格二】 Python风格

3.【风格三】逗号分隔风格(Comma separated values，csv)

4.【风格四】Numpy风格

5.【风格五】C语言风格

### 4.1.6输出其他常用数据结构

之前我们讲解了如何输出 Mat类型,其实,OpenCV同样支持使用运算符“<<”来打印其他常用的OpenCV数据结构，本小节会通过代码对其中典型的几种进行讲解。

1．定义和输出二维点

2．定义和输出三维点

3.定义和输出基于Mat 的std::vector

4．定义和输出std::vector点

### 4.2常用数据结构和函数

### 4.2.1点的表示:Point类

Point类数据结构表示了二维坐标系下的点,即由其图像坐标x和y指定的2D点。用法如下:
Point point;
point.x = 10;
point.y = 8;

### 4.2.2颜色的表示:Scalar类

Scalar(表示具有4个元素的数组,在OpenCV中被大量用于传递像素值,如RGB颜色值。而RGB颜色值为三个参数，其实对于Scalar 函数来说，如果用不到第四个参数，则不需要写出来;若只写三个参数，OpenCV会认为我们就想表示三个参数。

### 4.2.3尺寸的表示:Size类

通过在代码中对Size类进行“转到定义”操作，我们可以在......opencvisources\modulesicoreNincludelopencv2lcorelcore.hpp路径下,找到Size类相关的源代码:
    typedef size_<int> size2i;
    typedef size2i size;
其中，Size__是个模板类，在这里Size_<int>表示其类体内部的模板所代表的类型为int。那这两句代码的意思，就是首先给已知的数据类型Size_<int>起个新名字，叫 Size2i。然后又给已知的数据类型Size2i起个新名字，叫 Size。所以，连起来就是，Size_<int>、Size2i、Size这三个类型名等价。

### 4.2.4 矩形的表示：Rect类

    Rect类的成员变量有x、y、width、height，分别为左上角点的坐标和矩形的宽和高。常用的成员函数有:Size()返回值为Size; area()返回矩形的面积;contains(Point)判断点是否在矩形内;inside(Rect)函数判断矩形是否在该矩形内;tl)返回左上角点坐标;br()返回右下角点坐标。值得注意的是，如果想求两个矩形的交集和并集，可以用如下格式:

    Rect rect = recti &rect2;
    Rect rect - rect1 l rect2;

### 4.2.5 颜色空间转换:cvtColor()函数

cvtColor()函数是 OpenCV里的颜色空间转换函数，可以实现RGB颜色向HSV、HSI等颜色空间的转换，也可以转换为灰度图像。

### 4.3 基本图形的绘制
    
    本节我们将学习如何用Point在图像中定义2D点、如何使用Scalar表示颜色值。涉及到的绘制函数如下:

    ·用于绘制直线的line函数;
    ·用于绘制椭圆的ellipse函数;
    ·用于绘制矩形的rectangle函数;
    ·用于绘制圆的circle函数;
    ·用于绘制填充的多边形的fillPoly函数。

### 4.3.1 DrawEllipse(）函数的写法
    
    函数DrawEllipse 调用了OpenCV中的ellipse函数，将椭圆画到图像img 上，椭圆中心为点(WINDow_WIDTH/2.0,WINDOw_WIDTH/2.0 )，并且大小位于矩形(WINDOw_WIDTH/4.0,WINDOw_WIDTH/16.0 )内。椭圆旋转角度为angle，扩展的弧度从О度到360 度。图形颜色为Scalar(255,129,0)代表的蓝色，线宽(thickness)为2，线型(lineTypc)为8(8联通线型)。

### 4.3.2 DrawFilledCircle()函数的写法

    函数DrawFilledCircle()调用了OpenCV中的 circle函数，将圆画到图像img上，圆心由点center定义，圆的半径为WINDOw_WIDTH/32，圆的颜色为Scalar(0,0,255)，按 BGR的格式为红色，线粗定义为thickness = -1，因此绘制的圆是实心的。

### 4.3.3DrawPolygon()函数的写法

    函数 DrawPolygon()调用了OpenCV中的fillPoly函数，用于将多边形画到图像img 上，其中多边形的顶点集为ppt，要绘制的多边形顶点数目为npt，要绘制的多边形数量仅为1，多边形的颜色定义为白色Scalar(255,255,255)。

### 4.3.4DrawLine()函数的写法

    DrawLin()函数调用了OpenCV中的 line函数，用于在图像 img 上画一条从点 start到点 end 的直线段，线的颜色为Scalar(0,0,0)代表的黑色，线的粗细thickness为2，且此线为8联通( lineType = 8)。

### 4.3.5main函数的写法
    
    main函数的写法非常简单，先创建空白的Mat图像，然后调用函数绘制化学中的原子示例图，接着绘制组合图，最后显示绘制出的图像。

![markdown](https://i0.hdslb.com/bfs/album/165c53cc29cc6ffda4b34431d108609de3017e62.png@518w.png)


![markdown](https://i0.hdslb.com/bfs/album/f8156caaf716f1576e8e4754c5bf153b844b5f95.png@518w.png)



### 本章小结 


    本章我们主要学习了经常遇到的各种数据结构，主要是基础图像容器Mat的用法


### 第五章 core 组件进阶

### 5.1.1 图像在内存之中的存储方式

在之前的章节中，我们已经了解到图像矩阵的大小取决于所用的颜色模型，确切地说，取决于所用通道数。

而对多通道图像来说，矩阵中的列会包含多个子列，其子列个数与通道数相等。例如，如图5.2所示RGB颜色模型的矩阵。

可以看到，OpenCV中子列的通道顺序是反过来的——BGR而不是RGB。很多情况下，因为内存足够大，可实现连续存储，因此，图像中的各行就能一行一行地连接起来，形成一个长行。连续存储有助于提升图像扫描速度，我们可以使用isContinuous()来判断矩阵是否是连续存储的。相关示例会在接下来的内容中提供。

### 5.1.2颜色空间缩减

我们知道，若矩阵元素存储的是单通道像素，使用C或C++的无符号字符类型，那么像素可有256个不同值。但若是三通道图像，这种存储格式的颜色数就太多了（确切地说，有一千六百多万种)。用如此之多的颜色来进行处理，可能会对我们的算法性能造成严重影响。

其实，仅用这些颜色中具有代表性的很小的部分，就足以达到同样的效果。如此，颜色空间缩减(color space reduction）便可以派上用场了，它在很多应用中可以大大降低运算复杂度。颜色空间缩减的做法是:将现有颜色空间值除以某个输入值，以获得较少的颜色数。也就是“做减法”，比如颜色值0到9可取为新值0，10到19可取为10，以此类推。

这样，简单的颜色空间缩减算法就可由下面两步组成:

(1）遍历图像矩阵的每一个像素;

(2）对像素应用上述公式。

值得注意的是，我们这里用到了除法和乘法运算，而这两种运算又特别费时，所以，应尽可能用代价较低的加、减、赋值等运算来替换它们。此外，还应注意到，上述运算的输入仅能在某个有限范围内取值，如l uchar类型可取256个值。

由此可知，对于较大的图像，有效的方法是预先计算所有可能的值，然后需要这些值的时候，利用查找表直接赋值即可。查找表是一维或多维数组，存储了不同输入值所对应的输出值，其优势在于只需读取、无须计算。

### 5.1.3 LUT函数:Look up table操作

一个原型为operationsOnArrays:LUT()<lut>的函数来进行。它用于批量进行图像元素查找、扫描与操作图像。

### 5.1.4计时函数

另外有个问题是如何计时。可以利用这两个简便的计时函数———getTickCount()和 getTickFrequency()。

getTickCount(函数返回CPU自某个事件(如启动电脑)以来走过的时钟周期数

getTickFrequency)函数返回CPU一秒钟所走的时钟周期数。这样，我们就能轻松地以秒为单位对某运算计时。

### 5.1.5 访问图像中像素的三类方法

任何图像处理算法,都是从操作每个像素开始的。即使我们不会使用OpenCV提供的各种图像处理函数，只要了解了图像处理算法的基本原理，也可以写出具有相同功能的程序。在 OpenCV 中，提供了三种访问每个像素的方法。

·方法一指针访问:C操作符[ ];
·方法二―迭代器iterator;
·方法三动态地址计算。

这三种方法在访问速度上略有差异。debug模式下，这种差异非常明显，不过在release模式下，这种差异就不太明显了。我们通过一组程序来说明这几种方法。程序的目的是减少图像中颜色的数量，比如原来的图像是是256种颜色，我们希望将它变成64种颜色，那只需要将原来的颜色除以4（整除）以后再乘以4就可以了。

### 5.2ROI区域图像叠加&图像混合

在图像处理领域，我们常常需要设置感兴趣区域(ROI，region of interest)，来专注或者简化工作过程。也就是从图像中选择的一个图像区域，这个区域是图像分析所关注的重点。我们圈定这个区域，以便进行进一步处理。而且，使用ROI指定想读入的目标，可以减少处理时间，增加精度，给图像处理来带不小的便利。

定义ROI区域有两种方法:第一种是使用表示矩形区域的Rect。它指定矩形的左上角坐标(构造函数的前两个参数）和矩形的长宽（构造函数的后两个参数)以定义一个矩形区域。

另一种定义ROI的方式是指定感兴趣行或列的范围（Range)。Range是指从起始索引到终止索引(不包括终止索引）的一连段连续序列。cRange可以用来定义Range。

### 5.2.3计算数组加权和: addWeighted()函数

这个函数的作用是计算两个数组（图像阵列）的加权和。原型如下:
void (InputArray src1,double alpha,InputArray src2，double beta,doublegamna,OutputArray dst, int dtype=-1 );
·第一个参数，InputArray类型的 src1，表示需要加权的第一个数组，常常填一个Mat;
·第二个参数，double类型的alpha，表示第一个数组的权重;
第三个参数，InputArray类型的src2，表示第二个数组，它需要和第一个数组拥有相同的尺寸和通道数;
第四个参数，double类型的beta，表示第二个数组的权重值;
第五个参数，double类型的gamma，一个加到权重总和上的标量值。其含义通过接下来列出的式子自然会理解;
第六个参数，OutputArray类型的 dst，输出的数组，它和输入的两个数组拥有相同的尺寸和通道数;
第七个参数，int类型的dtype，输出阵列的可选深度，有默认值-1。当两个输入数组具有相同的深度时，这个参数设置为-1（默认值)，即等同于src1.depth()。

### 5.2.4 综合示例:初级图像混合

在前文介绍的设定感兴趣区域ROI和使用addWeighted 函数进行图像线性混合的基础上，我们还可以将二者结合起来使用，也就是先指定 ROI，再用addWeighted函数对指定的ROI区域的图像进行混合操作。



### 5.3 分离颜色通道、多通道图像混合

### 5.3.1通道分离: splitO函数

split函数用于将一个多通道数组分离成几个单通道数组。这里的array按语境翻译为数组或者阵列。

这个split函数的C++版本有两个原型，分别是:·C++: void split(const Mat& src,Mat*nvbegin);

. C++: void split(InputArray m,OutputArrayOfArrays mv);
变量介绍如下:
·第一个参数，InputArray类型的m或者const Mat&类型的src，填我们需要进行分离的多通道数组。
·第二个参数，OutputArrayOfArrays类型的mv，填函数的输出数组或者输出的 vector容器。
split函数分割多通道数组转换成独立的单通道数组.

### 5.3.2 通道合并: mergeO函数

merge())函数是split()函数的逆向操作——将多个数组合并成一个多通道的数组。它通过组合一些给定的单通道数组，将这些孤立的单通道数组合并成一个多通道的数组，从而创建出一个由多个单通道阵列组成的多通道阵列。它有两个基于C++的函数原型如下。

·CH+: void merge(const Mat* mv, size_tcount,OutputArray dst).Ct+: void merge(InputArrayOfArrays mv,OutputArray dst)变量介绍如下。
·第一个参数，mv。填需要被合并的输入矩阵或vector容器的阵列，这个mv参数中所有的矩阵必须有着一样的尺寸和深度。
·第二个参数，count。当mv为一个空白的C数组时，代表输入矩阵的个数，这个参数显然必须大于1。
·第三个参数，dst。即输出矩阵，和 mv[0]拥有一样的尺寸和深度，并且通道的数量是矩阵阵列中的通道的总数。
函数解析如下。
merge函数的功能是将一些数组合并成一个多通道的数组。关于组合的细节，输出矩阵中的每个元素都将是输出数组的串接。其中，第i个输入数组的元素被视为mv[i]。C一般用其中的Mat:.at()方法对某个通道进行存取，也就是这样用:channels.at(O)。
这里的Mat::.at()方法返回一个引用到指定的数组元素。注意是引用，相当于两者等价．也就是修改其中—个，另一个也会随之改变。

### 5.3.3 示例程序：多通道图像混合



### 5.4 图像对比度、亮度值调整

5.4.1 理论依据

首先了解一下算子的概念。一般的图像处理算子都是一个函数，它接受一个或多个输入图像，并产生输出图像。

本节所讲解的图像亮度和对比度的调整操作，其实属于图像处理变换中比较简单的一种——点操作( pointoperators)。点操作有一个特点:仅仅根据输入像素值(有时可加上某些全局信息或参数)，来计算相应的输出像素值。这类算子包括亮度( brightness）和对比度( contrast）调整、颜色校正( colorcorrection）和变换( transformations)。

两种最常用的点操作（或者说点算子)是乘上一个常数(对应对比度的调节)以及加上一个常数(对应亮度值的调节)。公式如下:
                        g(x)=a*f(x)+b

### 5.4.2 访问图片中的像素

访问图片中的像素有很多种方式，在本书5.1节“访问图像中的像素”中已有过比较系统的讲解。

### 5.5 离散傅里叶变换

离散傅里叶变换(Discrete Fourier Transform，缩写为DFT)，是指傅里叶变换在时域和频域上都呈现离散的形式，将时域信号的采样变换为在离散时间傅里叶变换（DTFT)频域的采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号做DFT，也应当对其经过周期延拓成为周期信号再进行变换。在实际应用中，通常采用快速傅里叶变换来高效计算 DFT。

5.5.1离散傅里叶变换的原理

简单来说，对一张图像使用傅里叶变换就是将它分解成正弦和余弦两部分，也就是将图像从空间域(spatial domain）转换到频（frequency domain)。

这一转换的理论基础为:任一函数都可以表示成无数个正弦和余弦函数的和的形式。傅里叶变换就是一个用来将函数分解的工具。

5.5.2 dft()函数详解

dft函数的作用是对一维或二维浮点数数组进行正向或反向离散傅里叶变换。

·第一个参数，InputArray类型的src。输入矩阵，可以为实数或者虚数。

·第二个参数，OutputArray类型的 dst。函数调用后的运算结果存在这里，其尺寸和类型取决于标识符，也就是第三个参数flags。

·第三个参数，int类型的flags。转换的标识符，有默认值0。

### 5.5.3返回DFT最优尺寸大小:getOptimaIDFTSize()函数

getOptimalDFTSize函数返回给定向量尺寸的傅里叶最优尺寸大小。为了提高离散傅里叶变换的运行速度，需要扩充图像，而具体扩充多少，就由这个函数来计算得到。

### 5.5.4扩充图像边界:copyMakeBorder()函数

copyMakeBorder函数的作用是扩充图像边界。

### 5.5.5 计算二维矢量的幅值:magnitude()函数

magnitude())函数用于计算二维朱量的幅值。

### 5.5.6计算自然对数: logO函数·

log()函数的功能是计算每个数组元素绝对值的自然对数。

### 5.5.7矩阵归一化: normalize()函数

normalize()的作用是进行矩阵归一化。

### 5.7 本章小结

本节中，我们学习了core模块的一些进阶知识点——操作图像中的像素、图像混合、分离颜色通道、调节图像的对比度和亮度、进行离散傅里叶变换，以及输入输出XML和YAML文件。



