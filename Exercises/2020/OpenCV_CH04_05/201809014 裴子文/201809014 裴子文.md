# CH04 OpenCV数据结构与基本绘图
## 基本图像容器Mat

### **4.1.1基本图像存储概述**
图像存储，指的是各种图形和影像在存储器 中最多可以存储多少帧的视频信号。

我们可以通过各种各样的方法从现实世界获取到数字图像，如借助相机、扫描仪、计算机摄像头或磁共振成像等。通常由显示屏上看到的都是真实而漂亮的图像，但是这些图像在转化到我们的数字设备中时，记录的却是图像中的每个点的数值。

### **4.1.2 Mat结构的使用**

在OpenCV的旧版本中是利用IplImage的C语言结构体在内存中存储图像，但是在退出前如果忘记release的话会造成内存泄漏，需要手动释放内存，管理麻烦。

OpenCV踏进2.0时代后 ，开始使用Mat类数据结构进行图像存储，上手方便。

关于Mat类有两点需要我们知道：

1、不必再手动为其开辟空间。

2、不必再在不需要时立即将空间释放。

其中，Mat是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸、存储方法、存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同，矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建副本是，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是常有的事。除非万不得已，不应该进行大图像的复制，因为这会降低程序的运行速度。

为了解决此问题，OpenCV使用了引用计数机制。其思路是让每个Mat对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则只复制信息头和矩阵指针，而不是复制矩阵。

### **4.1.3 像素值的存储方法**
存储像素值需要指定颜色空间和数据类型。

颜色空间是指针对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间， 只处理黑色和白色， 对它们进行组合便可以产生不同程度的灰色。
对于彩色方式则有更多种类的颜色空间， 但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。 RGB 颜色空间是最常用的一种颜色空间，。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素alpha ( A)。

每个组成元素都有自己的定义域， 而定义域収决于其数据类型，如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ，占一个字节或者 8 位，可以是有符号型（0 到255 之间）或无符号型( -127 到+127之间）。尽管使用三个 char 型元素已经可以表示 1600 万种可能的颜色（使用 RGB 颜色空间），但若使用 float ( 4 字节，32 位）或 double ( 8 字节，64 位）则能给出更加精细的颜色分辨能力。但同时也要切记， 增加元素的尺寸也会增加图像所占的内存空间。

### **4.1.4 创建 Mat 对象方法**

我们可以通过 Mat 的运算符 << 来查看其值。但要记住， Mat 的运算符 << 只对二维矩阵有效。 Mat 不但是一个非常有用的图像容器类，同时也是一个通用的矩阵类，我们也可以用它来创建和操作多维矩阵。

### **4.1.7示例程序**

![avatar](4.1代码.png)

实验结果如图

![avatar](4.1.png)

## 4.2常用的数据结构与函数
**1、点的表示：Point类**

Point类数据结构表示了二维坐标系下的点，既由其图像坐标x和y指定的2D点：

Point point;

point.x = 10;

point.y = 8;

或者：

Point point = point(10,8);

OpenCV中的定义：

typedef  Point_<int>  Point2i;

typedef  Point2i  Point;

typedef Point_<float>  Point2f;


**2、颜色表示：Scalar类**

Scalar()表示具有4个元素的数组，在OpenCV中被大量用于传递像素值，如RGB颜色值。而RGB颜色值为三个参数，其实对于Scalar函数来说，如果用不到第四个参数则不需要写出来；若只写三个参数，OpenCV会认为我们就想表示三个参数。

例如：给出以下颜色参数表达式：Scalar(a,b,c);   那么定义的RGB颜色值：红色分量为c，绿色分量为b，蓝色分量为a。

Scalar类的源头为Scalar_类，而Scalar_类是Vec4x的一个变种，我们常用的Scalar其实就是Scalar_<double>。这就是为什么很多函数的参数输入可以是Mat，也可以是Scalar。


**3、尺寸的表示：Size类**

OpenCV中对Size类的定义：

typedef   Size_<int>    Size2i;

typedef   Size2i   Size;

Size类的使用;  Size(5,5);   或者：XXX.width    XXX.height


**4、矩形的表示：Rect类**

Rect类的成员变量有x,y,width,height,分别为左上角点的坐标和矩形的宽和高。

常用的成员函数有：

Size()返回值为Size;
area()返回矩形的面积；

contains(Point)判断点是否在矩形内;

inside(Rect)函数判断矩形是否在改矩形内；

tl()返回左上角点坐标；

br()返回右下角点坐标。
求两个矩形的交集和并集：

Rect rect = rect1 & rect2;

Rect rect = rect1 | rect2;

矩形进行平移操作和缩放操作：

Rect rectShift = rect +point;

Rect rectScale = rect+size;

**5、颜色空间转换：cvtColor()函数**

cvtColor()可以实现RGB向HSV、HSI等颜色空间的转换，也可以转换为灰度图像。

## 4.3基本图像绘制

实验代码如下：

![avatar](显示俩图片1.png)

![avatar](显示俩图片2.png)

![avatar](显示俩图片3.png)

![avatar](显示俩图片4.png)

运行结果如下：

![avatar](基本图像绘制结果.png)

# CH05 core组件进阶

## 5.1 访问图像中的像素

### 5.1.1 图像在内存之中的存储方式

图像在内存之中的存储方式取决于通道数。

1、灰度图像

2、多通道：矩阵的类会包含多个子阵：比如RGB[注意opencv中子列的通道顺序是反过来的是BGR而不是RGB]

3、如果内存足够大，可以实现连续存储，因此，图像中的各行就能一行一行的连接起来，形成一个长行。连续存储有助于提升扫描速度，可以用isContinuous()判断是不是连续存储

### 5.1.2 颜色空间缩减
在对单通道图像进行处理时，像素的可能值为256个，但处理多通道时，像素的处理就会相当麻烦，其实用这些颜色中具有代表性的一小部分就可以达到同样的效果，所以颜色空间缩减就可以派上用场了。思路是这样的，我们可以把0-9范围的像素值取为0；10~19范围的取为1；也就是通过舍掉余数的方式得到较少的像素值。

### 5.1.5 访问图像中像素的三种方法

**1、指针访问**

代码如下：

![avatar](指针访问1.png)

![avatar](指针访问2.png)

**2、迭代器**

代码如下：

![avatar](迭代器.png)

![avatar](指针访问2.png)

**3、动态地址计算**

代码如下：

![avatar](第三种方法.png)

![avatar](指针访问2.png)

三种方法的运行结果如下：

![avatar](三种方法结果.png)

### **5.1.6遍历图像像素的14种方法**

14种方法代码如下：

![avatar](14种遍历代码1.png)

![avatar](14种遍历代码2.png)

![avatar](14种遍历代码3.png)

![avatar](14种遍历代码4.png)

![avatar](14种遍历代码5.png)

![avatar](14种遍历代码6.png)

![avatar](14种遍历代码7.png)

![avatar](14种遍历代码8.png)

![avatar](14种遍历代码9.png)

![avatar](14种遍历代码10.png)

![avatar](14种遍历代码11.png)

![avatar](14种遍历代码12.png)

![avatar](14种遍历代码13.png)

![avatar](14种遍历代码14.png)

![avatar](14种遍历代码15.png)

![avatar](14种遍历代码16.png)

![avatar](14种遍历代码17.png)

![avatar](14种遍历代码18.png)

结果如下图：

![avatar](图的14种遍历.png)

## 5.2 ROI区域图像叠加&图像混合

### **感兴趣区域：ROI**

ROI（region of interest），感兴趣区域。机器视觉、图像处理中，从被处理的图像以方框、圆、椭圆、不规则多边形等方式勾勒出需要处理的区域，称为感兴趣区域，ROI。在Halcon、OpenCV、Matlab等机器视觉软件上常用到各种算子（Operator）和函数来求得感兴趣区域ROI，并进行图像的下一步处理。

在图像处理领域，感兴趣区域(ROI) 是从图像中选择的一个图像区域，这个区域是你的图像分析所关注的重点。圈定该区域以便进行进一步处理。使用ROI圈定你想读的目标，可以减少处理时间，增加精度。

### **线性混合操作**


即可以把两张图像混合成一张图像的操作.

图像线性混合的数学原理

G(x)=(1-a)F(x)+aQ(x)

注意事项：

1，a的取值范围为0到1之间

2，F(x)和Q(x)为参与混合的两幅图像,G(x)表示输出图像

3，通过对两幅图像的每个像素值做线性加权得到最终的输出图像

4，两幅图像的大小和类型必须完全一致，如果把图像当成一个矩阵

则两个矩阵相加的前提是维度必须一致，否则没有相加的意义。

### **计算数组加权和：addWeighted函数**

在OpenCV中用于线性混合操作的API为addWeighted函数

void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype=-1);  

第一个参数，InputArray类型的src1，表示需要加权的第一个数组，常常填一个Mat。
第二个参数，alpha，表示第一个数组的权重
第三个参数，src2，表示第二个数组，它需要和第一个数组拥有相同的尺寸和通道数。
第四个参数，beta，表示第二个数组的权重值。
第五个参数，dst，输出的数组，它和输入的两个数组拥有相同的尺寸和通道数。
第六个参数，gamma，一个加到权重总和上的标量值。看下面的式子自然会理解。
第七个参数，dtype，输出阵列的可选深度，有默认值-1。;当两个输入数组具有相同的深度时，这个参数设置为-1（默认值），即等同于src1.depth（）。

### **综合示例：初级图像混合**

代码如下：

![avatar](5.2代码1.png)

![avatar](5.2代码2.png)

![avatar](5.2代码3.png)

运行结果：

![avatar](5.2效果1.png)
**图像叠加效果**

![avatar](5.2效果2.png)
**线性混合效果**

![avatar](5.2效果3.png)

**原图**

![avatar](5.2效果4.png)

## 5.3分离颜色通道，多通道图像混合

图像通道分离与合并：

OpenCV 中 imread() 函数默认加载图像文件，加载进来的是 3 通道彩色图像，色彩空间是RGB色彩空间。

通道顺序是：BGR （蓝色、绿色、红色）。

通道分离函数：split（）

通道合并函数：merge（）

## 示例程序：多通道图像混合

代码如下：
![avatar](5.3代码1.png)

![avatar](5.3代码2.png)

![avatar](5.3代码3.png)

![avatar](5.3代码4.png)

运行结果如下：

![avatar](5.3效果1.png)

![avatar](5.3效果2.png)

![avatar](5.3效果3.png)

## 5.4 图像对比度亮度调整

在图像像素公式g(x)=a*f(x)+b其中：

参数f(x)表示源图像像素。
参数g(x) 表示输出图像像素。
参数a（需要满足a>0）被称为增益（gain），常常被用来控制图像的对比度。
参数b通常被称为偏置（bias），常常被用来控制图像的亮度。
为了访问图像的每一个像素，我们使用这样的语法： image.at<Vec3b>(y,x)[c]

其中，y是像素所在的行， x是像素所在的列， c是R、G、B（对应0、1、2）其中之一。

因为我们的运算结果可能超出像素取值范围（溢出），还可能是非整数（如果是浮点数的话），所以我们要用saturate_cast对结果进行转换，以确保它为有效值。

这里的a也就是对比度，一般为了观察的效果，取值为0.0到3.0的浮点值，但是我们的轨迹条一般取值都会整数，所以在这里我们可以，将其代表对比度值的nContrastValue参数设为0到300之间的整型，在最后的式子中乘以一个0.01，这样就可以完成轨迹条中300个不同取值的变化。所以在式子中，我们会看到saturate_cast<uchar>( (g_nContrastValue*0.01)*(image.at<Vec3b>(y,x)[c] ) + g_nBrightValue )中的g_nContrastValue*0.01。

## 示例程序：图像对比度亮度调整

代码如下：

![avatar](对比度亮度1.png)

![avatar](对比度亮度2.png)

运行结果如下：

![avatar](对比度亮度结果.png)

## 5.5 离散傅里叶变换

离散傅里叶变换（Discrete Fourier Transform，DFT）傅里叶分析方法是信号分析的最基本方法，傅里叶变换是傅里叶分析的核心，通过它把信号从时间域变换到频率域，进而研究信号的频谱结构和变化规律。

**定义：**

离散傅里叶变换（DFT），是傅里叶变换在时域和频域上都呈现离散的形式，将时域信号的采样变换为在离散时间傅里叶变换（DTFT）频域的采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号作DFT，也应当将其看作经过周期延拓成为周期信号再作变换。在实际应用中通常采用快速傅里叶变换以高效计算DFT。

### **原理**

对一张图像使用傅里叶变换就是将它分解成正弦和余弦两部分，也就是将图像从空间域（spatial domain）转换到频率域（frequency domain）。二维图像的傅里叶变换的数学公式：

![avatar](原理.png)

其中的f是空间域值，F是频率域值。转换后频率域值是复数。显示傅里叶变换之后的结果需要使用实数图像（real image）加虚数图像（complex image），或者幅度图像（magitude image）加相位图像（phase image）的形式。在实际的图像处理过程中，仅仅使用了幅度图像，因为幅度图像包含了原图像的几乎所有处理所需的集合信息。在频域里面，对于一幅图像，高频部分代表了图像的细节、纹理信息；低频部分代表了图像的轮廓信息。如果对一幅精细图像使用低通滤波器，那么滤波后的结果就只剩下轮廓了。这与信号处理的基本思想是相通的。如果图像受到的噪声恰好位于某个特定的“频率”范围内，则可以通过滤波器来恢复原来的图像。傅里叶变换在图像处理中可以做到图像增强与图像去噪、图像分割之边缘检测、图像的特征提取、图像压缩等。

**OpenCV傅里叶变换所用函数**

**dft()函数**的作用是对一维或二维浮点数数组进行正向或反向离散傅里叶变换。关于这个函数的更详尽的介绍请看OpenCV的官方文档。

**getOptimalDFTSize()函数**返回给定向量尺寸的傅里叶最优尺寸大小。为了提高离散傅里叶变换的运行速度，需要扩充退选哪个，而具体扩充多少，就由这个函数计算得到。

**copyMakeBorder()函数**的作用是扩充图像边界。

**magnitude()函数**用于计算二维矢量的幅值。

**log()函数**用于计算每个数组元素绝对值的自然对数。

其原理：**dst(I)={x|log|src(I)| if src(I)≠0, C otherwise}**；

**normalize()函数**用于矩阵的归一化。

## 示例程序：离散傅里叶变换

代码如下：

![avatar](5.5代码1.png)

![avatar](5.5代码2.png)

![avatar](5.5代码3.png)

运行结果如下：

![avatar](5.5效果图.png)

## 5.6 输入输出XML和YAML文件

**XML和YAML文件简介**

## XML

**概述：**

可扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。

**格式特性：**

XML与Access，Oracle和SQL Server等数据库不同，数据库提供了更强有力的数据存储和分析能力，例如：数据索引、排序、查找、相关一致性等，XML仅仅是存储数据。事实上XML与其他数据表现形式最大的不同是：它极其简单，这是一个看上去有点琐细的优点，但正是这点使XML与众不同。

XML与HTML的设计区别是：XML被设计为传输和存储数据，其焦点是数据的内容。而HTML被设计用来显示数据，其焦点是数据的外观。HTML旨在显示信息，而 XML旨在传输信息。

XML和HTML语法区别：HTML的标记不是所有的都需要成对出现，XML则要求所有的标记必须成对出现；HTML标记不区分大小写，XML则大小敏感，即区分大小写。

**读写：**

XML读写我所熟悉的有两种方式，一种是通过JavaScript来获取XML值，一个是用PHP来读取。XML的编写大家可以参考着手册，XML格式比较自由，可以自定义标签，但有一个原则就是要直观。

## YAML

**简介：**

YAML 作为一种比 XML 更为简单易读的序列化语言，正越来越多地被用于应用及配置文件的开发中。本文将简单介绍 YAML 的现状，YAML 与 XML 相比的优劣势，并通过实际的例子给出 YAML 的典型应用场景及其使用方法（涵盖 c/c++、ruby、PHP等）。

**优势：**

YAML的可读性好。

YAML和脚本语言的交互性好。

YAML使用实现语言的数据类型。

YAML有一个一致的信息模型。

YAML易于实现。

上面5条也就是XML不足的地方。同时，YAML也有XML的下列优点：

YAML可以基于流来处理；

YAML表达能力强，扩展性好。

总之，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。



**语法：**

Structure通过空格来展示。Sequence里的项用"-"来代表，Map里的键值对用":"分隔.

这几乎就是所有的语法了.

## FileStorage类操作文件的使用引导

FileStorage类是OpenCV中用来进行文件操作的封装类，可以对XML,YAML,txt甚至doc文件进行读写操作。在使用opencv时经常需要对特征数据等进行保存，这时候通常会选择XML文件或者YAML文件。xml和yaml都是属于标记语言，开发者可以根据自身需要定义标签。同时他们也是一种语义/结构化语言，他们可以描述文档的结构和语义。FileStorage类可以对C++的基础数据类型（int,float,double等）、容器类（vector,maps）、opencv定义的数据结构（Mat，Scalar等）进行读写操作。

FileStorage类的使用流程如下：

（1）实例化一个FileStorage类对象

（2）使用流操作符<<进行文件写入，>>进行文件读取，类似C++中的文件操作

（3）使用FileStorage：：release（）函数析构掉类对象，并关闭文件

## 示例程序：XML和YAML文件的写入

代码如下：

![avatar](xml写入代码1.png)

![avatar](xml写入代码2.png)

运行结果如下：

![avatar](xml写入.png)

## 示例程序：XML和YAML文件的读取

代码如下：

![avatar](xml读取代码1.png)

![avatar](xml读取代码2.png)

运行结果如下：

![avatar](xml读取结果.png)